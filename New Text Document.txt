public class CSVReader {
    
    private static final Logger logger = LoggerFactory.getLogger(CSVReader.class);
    private static final ErrorMessageUtil errorMessageUtil = ErrorMessageUtil.getInstance();
    private final SkuValidator skuValidator;
    private final String csvFolderPath;
    
    // CSV file name constants
    private static final String SKU_CSV_FILE = "Skus.csv";
    private static final String CSV_DELIMITER = ",";
    private static final int EXPECTED_SKU_COLUMNS = 4;
    
    // CSV Header indices
    private static final int SKU_ID_INDEX = 0;
    private static final int SKU_NAME_INDEX = 1;
    private static final int PRICE_INDEX = 2;
    private static final int QUANTITY_INDEX = 3;
    
    /**
     * Constructor with configurable CSV folder path.
     * 
     * @param csvFolderPath Root folder path for CSV files
     */
    public CSVReader(String csvFolderPath) {
        this.csvFolderPath = csvFolderPath;
        this.skuValidator = new SkuValidator();
        logger.info("CSVReader initialized with folder path: {}", csvFolderPath);
    }
    
    /**
     * Read all SKUs from CSV file.
     * 
     * @return List of valid Sku objects
     * @throws CSVFileNotFoundException if file not found
     * @throws CSVReadException if error reading file
     * @throws CSVEmptyFileException if file is empty
     */
    public List<Sku> getAllSkus() 
            throws CSVFileNotFoundException, CSVReadException, CSVEmptyFileException {
        
        logger.info(LogMessages.METHOD_ENTRY, "getAllSkus");
        
        Path filePath = Paths.get(csvFolderPath, SKU_CSV_FILE);
        logger.info(LogMessages.CSV_READING_STARTED, filePath);
        
        // Check if file exists
        if (!Files.exists(filePath)) {
            String errorMessage = errorMessageUtil.getErrorMessage(ErrorCodes.CSV_FILE_NOT_FOUND);
            logger.error(LogMessages.CSV_FILE_NOT_FOUND, filePath);
            throw new CSVFileNotFoundException(
                ErrorCodes.CSV_FILE_NOT_FOUND,
                errorMessage + ": " + filePath
            );
        }
        
        logger.debug(LogMessages.CSV_FILE_FOUND, filePath);
        
        List<Sku> skuList = new ArrayList<>();
        int lineNumber = 0;
        int validRecords = 0;
        int invalidRecords = 0;
        
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath.toFile()))) {
            
            String line;
            boolean isHeader = true;
            
            while ((line = reader.readLine()) != null) {
                lineNumber++;
                
                // Skip header row
                if (isHeader) {
                    isHeader = false;
                    logger.debug("Skipping header row: {}", line);
                    continue;
                }
                
                // Skip empty lines
                if (line.trim().isEmpty()) {
                    logger.debug("Skipping empty line at: {}", lineNumber);
                    continue;
                }
                
                try {
                    logger.debug(LogMessages.CSV_PARSING_ROW, lineNumber);
                    Sku sku = parseSkuFromLine(line, lineNumber);
                    
                    if (sku != null) {
                        skuList.add(sku);
                        validRecords++;
                        logger.debug(LogMessages.CSV_ROW_PARSED, sku);
                    }
                    
                } catch (ValidationException | IllegalArgumentException e) {
                    invalidRecords++;
                    logger.warn(LogMessages.CSV_ROW_VALIDATION_FAILED, lineNumber, e.getMessage());
                    logger.debug(LogMessages.CSV_ROW_SKIPPED, lineNumber, line);
                    // Continue processing other rows
                }
            }
            
            logger.info(LogMessages.CSV_READING_COMPLETED, validRecords, invalidRecords);
            
            // Check if file was empty (no valid records)
            if (skuList.isEmpty()) {
                String errorMessage = errorMessageUtil.getErrorMessage(ErrorCodes.CSV_EMPTY_FILE);
                logger.error(LogMessages.CSV_EMPTY_FILE, filePath);
                throw new CSVEmptyFileException(
                    ErrorCodes.CSV_EMPTY_FILE,
                    errorMessage + ": " + filePath
                );
            }
            
            logger.info(LogMessages.METHOD_EXIT, "getAllSkus");
            return skuList;
            
        } catch (IOException e) {
            String errorMessage = errorMessageUtil.getErrorMessage(ErrorCodes.CSV_READ_ERROR);
            logger.error(LogMessages.CSV_READ_ERROR, filePath, e);
            throw new CSVReadException(
                ErrorCodes.CSV_READ_ERROR,
                errorMessage + ": " + e.getMessage(),
                e
            );
        }
    }
    
    /**
     * Parse a single line from CSV into Sku object.
     * 
     * @param line CSV line to parse
     * @param lineNumber Line number for logging
     * @return Sku object or null if parsing fails
     * @throws ValidationException if validation fails
     */
    private Sku parseSkuFromLine(String line, int lineNumber) throws ValidationException {
        
        String[] columns = line.split(CSV_DELIMITER, -1);
        
        // Check column count
        if (columns.length != EXPECTED_SKU_COLUMNS) {
            logger.warn("Invalid column count at line {}: expected {}, got {}", 
                       lineNumber, EXPECTED_SKU_COLUMNS, columns.length);
            return null;
        }
        
        // Extract and trim values
        String skuId = columns[SKU_ID_INDEX].trim();
        String skuName = columns[SKU_NAME_INDEX].trim();
        String priceStr = columns[PRICE_INDEX].trim();
        String quantityStr = columns[QUANTITY_INDEX].trim();
        
        // Validate fields
        skuValidator.validateSkuId(skuId);
        skuValidator.validateSkuName(skuName);
        
        // Parse and validate price
        BigDecimal price;
        try {
            price = new BigDecimal(priceStr);
            skuValidator.validatePrice(price);
        } catch (NumberFormatException e) {
            logger.warn("Invalid price format at line {}: {}", lineNumber, priceStr);
            throw new ValidationException(
                ErrorCodes.VALIDATION_PRICE_INVALID,
                "Invalid price format: " + priceStr,
                "price",
                priceStr
            );
        }
        
        // Parse and validate quantity
        int quantity;
        try {
            quantity = Integer.parseInt(quantityStr);
            skuValidator.validateQuantity(quantity);
        } catch (NumberFormatException e) {
            logger.warn("Invalid quantity format at line {}: {}", lineNumber, quantityStr);
            throw new ValidationException(
                ErrorCodes.VALIDATION_QUANTITY_INVALID,
                "Invalid quantity format: " + quantityStr,
                "quantity",
                quantityStr
            );
        }
        
        // Build and return Sku object
        return new Sku.Builder()
                .skuId(skuId)
                .skuName(skuName)
                .price(price)
                .availableQuantity(quantity)
                .build();
    }
}
